defmodule Livex.JSX do
  @moduledoc """
  Provides macros for emitting client-side events from LiveViews/LiveComponents.
  The client-side event name to be dispatched is looked up from assigns
  using a key derived from the provided event suffix (e.g., assigns[:"phx-suffix"]).
  The target is also resolved from assigns or options within the macro.
  To use the `emit` macro, call it as `Livex.JS.emit(...)`.
  """

  defmacro __using__(_opts \\ []) do
    quote do
      require Livex.JSX
    end
  end

  alias Phoenix.LiveView.JS

  # --- Emit Macros (Public Interface: Livex.JS.emit) ---

  @doc """
  Generates a JS command to emit a client-side event, chained on an existing JS struct, with options.
  Example: `Livex.JS.emit(my_js_chain, "event_suffix", values: %{...})`
  """
  # Arity 3: emit(%JS{}, event_suffix, opts_list)
  defmacro emit(%Phoenix.LiveView.JS{} = js_ast, event_name_suffix_ast, opts_list_ast) do
    quote location: :keep do
      # This code is generated by the macro and runs at runtime in the caller's context
      # Capture assigns from the calling scope
      _assigns = var!(assigns)
      _event_name_suffix = unquote(event_name_suffix_ast)
      _key_for_event_name = String.to_existing_atom("phx-#{_event_name_suffix}")
      _resolved_client_event = Map.fetch!(_assigns, _key_for_event_name)
      # Evaluate opts_list_ast once
      _opts = unquote(opts_list_ast)
      # Resolve target here
      _resolved_target = Livex.JSX.get_target(_assigns, _opts)

      Livex.JSX.build_push_op(
        unquote(js_ast),
        # Pass pre-resolved target
        _resolved_target,
        _resolved_client_event,
        # Pass evaluated opts
        _opts
      )
    end
  end

  @doc """
  Generates a JS command to emit a client-side event, chained on an existing JS struct, without options.
  Example: `Livex.JS.emit(my_js_chain, "event_suffix")`
  """
  # Arity 2: emit(%JS{}, event_suffix)
  defmacro emit(%Phoenix.LiveView.JS{} = js_ast, event_name_suffix_ast) do
    quote location: :keep do
      _assigns = var!(assigns)
      _event_name_suffix = unquote(event_name_suffix_ast)
      _key_for_event_name = String.to_existing_atom("phx-#{_event_name_suffix}")
      _resolved_client_event = Map.fetch!(_assigns, _key_for_event_name)
      # Resolve target with empty opts
      _resolved_target = Livex.JSX.get_target(_assigns, [])

      Livex.JSX.build_push_op(
        unquote(js_ast),
        # Pass pre-resolved target
        _resolved_target,
        _resolved_client_event,
        # Explicitly pass empty opts_list
        []
      )
    end
  end

  # Arity 2: emit(event_suffix, opts_list)
  defmacro emit(event_name_suffix_ast, opts_list_ast) do
    quote location: :keep do
      _assigns = var!(assigns)
      _event_name_suffix = unquote(event_name_suffix_ast)
      _key_for_event_name = String.to_existing_atom("phx-#{_event_name_suffix}")
      _resolved_client_event = Map.fetch!(_assigns, _key_for_event_name)
      # Evaluate opts_list_ast once
      _opts = unquote(opts_list_ast)
      # Resolve target here
      _resolved_target = Livex.JSX.get_target(_assigns, _opts)

      Livex.JSX.build_push_op(
        # build_push_op/3 for new JS struct
        # Pass pre-resolved target
        _resolved_target,
        _resolved_client_event,
        # Pass evaluated opts
        _opts
      )
    end
  end

  @doc """
  Generates a JS command to emit a client-side event (new JS chain) without options.
  Example: `Livex.JS.emit("event_suffix")`
  """
  # Arity 1: emit(event_suffix)
  defmacro emit(event_name_suffix_ast) do
    quote location: :keep do
      _assigns = var!(assigns)
      _event_name_suffix = unquote(event_name_suffix_ast)
      _key_for_event_name = String.to_existing_atom("phx-#{_event_name_suffix}")
      _resolved_client_event = Map.fetch!(_assigns, _key_for_event_name)
      # Resolve target with empty opts
      _resolved_target = Livex.JSX.get_target(_assigns, [])

      Livex.JSX.build_push_op(
        # build_push_op/2 for new JS struct and empty opts
        # Pass pre-resolved target
        _resolved_target,
        _resolved_client_event,
        # Explicitly pass empty opts_list
        []
      )
    end
  end

  # --- Core Helper Functions (Called by Macro-Generated Code) ---
  # These functions now take the pre-resolved `resolved_target`.

  @doc false
  # Builds the JS.push command on an existing JS struct.
  def build_push_op(%Phoenix.LiveView.JS{} = js, resolved_target, client_event_name, opts_list) do
    value_map = Keyword.get(opts_list, :value, %{})
    # `resolved_target` is now passed directly
    JS.push(js, "#{client_event_name}",
      target: resolved_target,
      value: value_map
    )
  end

  @doc false
  # Shorthand for `build_push_op/4` when `opts_list` is empty and a JS struct is provided.
  def build_push_op(%Phoenix.LiveView.JS{} = js, resolved_target, client_event_name) do
    build_push_op(js, resolved_target, client_event_name, [])
  end

  @doc false
  # Builds the JS.push command, creating a new JS struct.
  # `resolved_target` is the first argument here.
  def build_push_op(resolved_target, client_event_name, opts_list) do
    build_push_op(%JS{}, resolved_target, client_event_name, opts_list)
  end

  @doc false
  # Shorthand for `build_push_op/3` (which creates a new JS struct) when `opts_list` is empty.
  def build_push_op(resolved_target, client_event_name) do
    build_push_op(%JS{}, resolved_target, client_event_name, [])
  end

  # --- Public Helper for Target Resolution (Called by Macro-Generated Code) ---
  # Made public (`def`) so the macro-generated code can call `Livex.JS.get_target`.
  @doc false
  def get_target(assigns, opts_list) do
    case Keyword.get(opts_list, :to) do
      # No :to in opts_list, try deriving from assigns
      nil ->
        get_target_from_assigns(assigns)

      # Target explicitly provided in opts_list
      explicit_target ->
        explicit_target
    end
  end

  # Made public (`def`) as it's part of the `get_target` logic callable by macro-generated code.
  @doc false
  def get_target_from_assigns(%{"phx-target": %Phoenix.LiveComponent.CID{cid: cid_val}}),
    do: cid_val

  def get_target_from_assigns(_assigns), do: nil

  defmacro assign_data(key, val) do
    quote do
      Livex.JSX.assign_data(
        var!(assigns)[:myself],
        unquote(key),
        unquote(val)
      )
    end
  end

  def assign_data(target, key, value) do
    JS.push("__component_action",
      target: target,
      value: %{key => value}
    )
  end
end
